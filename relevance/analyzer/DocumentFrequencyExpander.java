package analyzer;

import indexer.TermFreq;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import query.QueryRecord;
import util.Global;
import util.Logger;
import util.Logger.MsgType;

public class DocumentFrequencyExpander extends Expander {

	//determine if any of the top 10 words appear in more than 4 documents
	//if it does, we can say with high confidence that is a relevant word
	//if there are two such words, we need to consider both of them as they may
	//form a phrase
	@Override
	public void expand(String[] query, List<String> revisedQuery) {

		setQueries(query);
		
		Logger myLogger = Logger.getInstance();
		List<String> relevantTerms = Global.getRelevantTerms();
		
		List<TermFreq> myTopWordsList = new ArrayList<TermFreq>();
		List<String> candidates = new ArrayList<String>();;
		
		//ignore wiki pages
		for (String s : relevantTerms) {	
			int occurrence = 0;
			for (QueryRecord result : Global.getPositives())
			{	
				String content = result.getTitle() + result.getDescription();		
				content = content.replaceAll("[^\\w\\s]", "");//replace punctuations
				List<String> contentList = Arrays.asList(content.split("\\s+"));
							
				Global.sanitizeList(contentList);
					
				if(contentList.contains(s))
					occurrence++;
			}	
					
			myTopWordsList.add(new TermFreq(s, occurrence));
		}
			
		Collections.sort(myTopWordsList);
		Collections.reverse(myTopWordsList);
		
		myLogger.write(myTopWordsList.toString(), MsgType.DEBUG);
			
		Iterator<TermFreq> itr = myTopWordsList.iterator();
		int count = 0;
		while(itr.hasNext() && count < 2) {
			TermFreq termFreq = itr.next();
			if(termFreq.getFreq() > 2)
				candidates.add( termFreq.getTerm() );
			count++;	
		}
			
		if(candidates.size() > 0)
		{
			if (candidates.size() == 2)
				analyzeOrder(candidates);
			revisedQuery.addAll(originalQuery);
			revisedQuery.addAll(candidates);
			
			myLogger.write("Revised Query generated by Document Frequency Expander:" +
					revisedQuery.toString(), MsgType.DEBUG);
		}
	}
		
	//The order of candidates can be somewhat determined 
	//if we compare the position of candidate strings with respect to each other
	//and if there is a pattern found if one appears before the other always
	//otherwise the order of two words added will not matter
		
	private void analyzeOrder(List<String> candidates)
	{
		int swap = 0;
		Iterator<QueryRecord> iter = Global.getPositives().iterator();
		while(iter.hasNext() && swap == 0)
		{	
			QueryRecord result = iter.next();
			
			String content = result.getTitle() + result.getDescription();		
			content = content.replaceAll("[^\\w\\s]", "");//replace punctuations
			List<String> contentList = Arrays.asList(content.split("\\s+"));

			Global.sanitizeList(contentList);
				
			if ( contentList.contains(candidates.get(0)) && 
					contentList.contains(candidates.get(1)))
			{
				if ( contentList.indexOf(candidates.get(0)) > 
						contentList.indexOf(candidates.get(1)) )
					swap++;
			}
		}
			
		//if there are at least 3 documents where both the words co-exist 
		//and one always exist after the other
		if (swap > 2)
		{
			String temp = candidates.get(0);
			candidates.set(0, candidates.get(1));
			candidates.set(1, temp);
		}
	}

}
